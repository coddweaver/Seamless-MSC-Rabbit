# Seamless Talk (RabbitMQ)

Seamless Talk (RabbitMQ) is a java library for easy and fast developing microservices communication on RabbitMQ bus.

Main features:

* queues and exchanges auto generation and binding, based on your configuration
* java api code generation between services
* seamless error transferring

## Step-by-step guide

This step-by-step guide will quickly get you started on SeamlessTalk (RabbitMQ) basics.

### 0. Preparations

You need to know some basics about this library:

* `Contract` - is an interface marked with @SeamlessTalkRabbitContract annotation
* `Listener` - is a class implementing the contract and marked with @SeamlessTalkRabbitListener, where every interface's overriden method
  must be marked with @RabbitHandler.
* `Generated API` - is a class which is auto-generated by contract.
* `DTO (Data transfer object)` - a common class for data transferring between modules. I hope you knew it, but still its my duty to name it.

### 1. Project structure

You need to create a share library for all your services. It will contains common objects (ex. contracts and DTOs). It needs to exist
because all data will be serialized and deserialized using full class name and it shall be the same everywhere.

In this example it will be called `shared-lib`. Also let's create two microservice modules: `library-api`, and `repository-manager`. The
first one will implement a rest controllers to send requests by RabbitMQ to the second one.

Also, you need to define RabbitMQ connection parameters in every microservice properties. The most common setup will be:

```
spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
```

More information you can find at Spring AMQP docs.

### 2. Contracts creation

After moduled has been created you need to define your contracts. There are a few steps to do it:

* create an interface with the name of contract. Usually it ends with '*Contract'. Ex. LibrarySearchContract.
* mark it with @SeamlessTalkRabbitContract and set desired annotation arguments, ex. exchangeType (direct or fanout).
* define contract methods inside. Method parameter means incoming payload type and return value - outcoming.

#### Important note:

* Due to implementation features of `AMQP`, there is single payload in message. So, you can put only one argument to contract methods. But
  it not forbides you to create a DTO with all arguments you need inside.

For example, let's create a contract `LibraryIOContract` with two methods:

* FileDto get(String path)
* boolean save(FileDto request)

You will have a such code:

```java
@SeamlessTalkRabbitContract
public interface LibraryIOContract {

    FileDto get(String path);

    boolean save(FileDto request);
}
```

Where `FileDto` is a common class defined in `share-lib:

```java
@Data
@NoArgsConstructor
@SuperBuilder
public class FileDto {

    private byte[] data;
    private String path;
}
```

I hope you don't have anything against `Lombok` :)

Now you can run `build` task and see how will be generated api class implementing this contract. Like this:

```java
@Service
@Primary
public class LibraryIOContractRabbitApi extends AbstractRabbitApi implements LibraryIOContract {

    private AmqpTemplate amqpTemplate;

    private Binding binding;

    public LibraryIOContractRabbitApi(AmqpTemplate amqpTemplate, RoutesGenerator routesGenerator) {
        this.amqpTemplate = amqpTemplate;
        this.binding = routesGenerator.getBinding(LibraryIOContract.class);
    }

    @Override
    public FileDto get(String payload) {
        return convertSendAndReceive(amqpTemplate, binding.getExchange(), binding.getRoutingKey(), payload);
    }

    @Override
    public boolean save(FileDto payload) {
        return convertSendAndReceive(amqpTemplate, binding.getExchange(), binding.getRoutingKey(), payload);
    }
}
```

The mark that you set up all correctly will be in build logs:

```
> Task :examples-2-ms-with-shared-lib-shared-lib:compileJava
Note: Started Seamless Talk rabbit api generation for found contracts: 
  com.coddweaver.seamless.talk.rabbit.examples.sharedlib.api.repositorymanager.contracts.LibraryIOContract
```

Now all prepartions in shared library has done. Let's go to the microservices.

### 3. Listener creation

You need to create a class implementing desired contract and mark it with @SeamlessTalkRabbitListener.

Let's create a listener inside `repository-manager` module. Like this:

```java
@SeamlessTalkRabbitListener
public class LibraryIOListener implements LibraryIOContract {

    @Override
    @RabbitHandler
    public FileDto get(String filePath) {
        throw new NotImplementedException();
    }

    @Override
    @RabbitHandler
    public boolean save(FileDto request) {
        return true;
    }
}
```

The implementation of methods is your own business. Now we will just throw an exception back.

That's all you need to do. Let's try to use it,

### 4. Generated API usage

Let's go to `library-api` module and create a rest controller with autowired `LibrarySearchContract` instance.

```java

@RestController
@RequestMapping("library")
public class LibraryController {

    @Autowired
    private LibrarySearchContract librarySearchContract;

    ...

}
```

After it let's add some methods inside to call our contract functionality:

```java
@RequestMapping("/save")
boolean save(MultipartFile file,String path){
        FileDto payload=FileDto.builder()
        .data(file.getBytes())
        .path(path)
        .build();

        return libraryIOContract.save();
}
```

Let's `run` both microservices and request `save` REST-method. If it returns `true` response, then you made all correctly and your
connection between microservices is set up.

If you are confused why it returned `true`, your implemented `LibraryIOListener.save` method always returns `true` (see p.3).

Also, you can request `get` REST-method and see in `library-api` logs that the `NotImplementedException` thrown in `repository-manager` was
fully transferred to `library-api` module and re-thrown as usual exception:

```java
...
com.coddweaver.seamless.talk.rabbit.exceptions.NotImplementedException: null
        at com.coddweaver.seamless.talk.rabbit.repositorymanager.listeners.LibraryIOListener.get(LibraryIOListener.java:22) ~[main/:na]
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]
...
```

### Conclusion

That's all you need to know to create simple connection between microservices using `SeamlessTalk (RabbitMQ)`. More complex examples you can
find in [examples](https://github.com/coddweaver/seamless-talk-rabbit/tree/main/examples) folder.




